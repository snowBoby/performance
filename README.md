# performance
前端性能优化与代码书写规范

## 书写规范

* 变量和函数命名 ：变量名应为名词如 car 或 person；函数名应该以动词开始，如 getName()。返回布尔类型值的函数一般以 is 开头，如isEnable()；变量和函数都应使用合乎逻辑的名字，不要担心长度。长度问题可以通过后处理和压缩
* 变量初始化：由于在 JavaScript 中变量是松散类型的，很容易就忘记变量所应包含的数据类型。
* 修改CSS的类代替样式
* 避免使用CSS表达式
* 解耦应用逻辑／事件处理程序：
    * 勿将 event 对象传给其他方法；只传来自 event 对象中所需的数据；
    * 任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行；
    * 任何事件处理程序都应该处理事件，然后将处理转交给应用逻辑。
* 永远不修改不是由你所有的对象。所谓拥有对象，就是说这个对象是你创建的，比如你自己创建的自定义类型或对象字面量。而 Array、document 这些显然不是你的，这样为避免那天浏览器更新的方法与你通过Prototype自定义写的方法名一样，但是功能不一致的问题。你依然可以通过以下方式为对象创建新的功能：
    * 创建包含所需功能的新对象，并用它与相关对象进行交互；
    * 创建自定义类型，继承需要进行修改的类型。然后可以为自定义类型添加额外功能。
* 避免全局量：最多创建一个全局变量，让其他对象和函数存在其中，单一的全局量的延伸便是命名空间的概念。原因：首先，全局变量可能覆盖了 window 上的属性，可能会与其他功能产生冲突；其次，它有助消除功能作用域之间的混淆。
* 如果值应为一个引用类型，使用 instanceof 操作符检查其构造函数；如果值应为一个基本类型，使用 typeof 检查其类型；
* 使用常量：
    * 重复值——任何在多处用到的值都应抽取为一个常量。这就限制了当一个值变了而另一个没变的时候会造成的错误。这也包含了 CSS 类名。
    * 用户界面字符串 —— 任何用于显示给用户的字符串，都应被抽取出来以方便国际化。
    * URLs ——在 Web 应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的 URL。
    * 任意可能会更改的值 —— 每当你在用到字面量值的时候，你都要问一下自己这个值在未来是不是会变化。如果答案是“是”，那么这个值就应该被提取出来作为一个常量。
* 避免全局查找：随着作用域链中的作用域数量的增加，访问当前作用域以外的变量的时间也在增加。访问全局变量总是要比访问局部变量慢，因为需要遍历作用域链。只要能减少花费在作用域链上的时间，就能增加脚本的整体性能。解决方案：将在一个函数中会用到多次的全局对象存储为局部变量总是没错的
```
function updateUI(){
 var imgs = document.getElementsByTagName("img");
 for (var i=0, len=imgs.length; i < len; i++){
    imgs[i].title = document.title + " image " + i;
 }
 var msg = document.getElementById("msg");
 msg.innerHTML = "Update complete.";
}
//该函数可能看上去完全正常，但是它包含了三个对于全局 document 对象的引用。如果在页面上有多个图片，那么 for 循环中的 document 引用就会被执行多次甚至上百次，每次都会要进行作用域链查找。通过创建一个指向 document 对象的局部变量，就可以通过限制一次全局查找来改进这个函数的性能：
function updateUI(){
 var doc = document; //现在的函数只有一次全局查找，肯定更快
 var imgs = doc.getElementsByTagName("img");
 for (var i=0, len=imgs.length; i < len; i++){
    imgs[i].title = doc.title + " image " + i;
 }
 var msg = doc.getElementById("msg");
 msg.innerHTML = "Update complete.";
} 
```

* 避免 with 语句：和函数类似，with 语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度。由于额外的作用域链查找，在 with 语句中执行的代码肯定会比外面执行的代码要慢。在大多数情况下，可以用局部变量完成相同的事情而不引入新的作用域。下面是一个例子：
```
function updateBody(){
 with(document.body){
    alert(tagName);
    innerHTML = "Hello world!";
 }
}
//这段代码中的 with 语句让 document.body 变得更容易使用。其实可以使用局部变量达到相同的效果，如下所示：
function updateBody(){
 var body = document.body
 alert(body.tagName);
 body.innerHTML = "Hello world!";
} 
```

* 使用数字位置查找。对象上的任何属性查找都要比访问变量（value）或者直接访问数组元素（value[0]）花费更长时间，因为必须在原型链中对拥有该名称的属性进行一次搜索。简而言之，属性查找越多，执行时间就越长。进一步讲，如果既可以用数字化的数组位置进行访问，也可以使用命名属性（诸如 NodeList对象），那么使用数字位置。一旦多次用到对象属性，应该将其存储在局部变量中。eg:` window.location.href.substring(window.location.href.indexOf("?"))`在这段代码中，有 6 次属性查找：window.location.href.substring()有 3 次，window.location.href.indexOf()又有 3 次。其实可以将 window.location.href提取为变量。
* 优化循环：
    (1) 减值迭代或增值（终止条件提前）——大多数循环使用一个从 0 开始、增加到某个特定值的迭代器。在很多情况下，从最大值开始，在循环中不断减值的迭代器更加高效。
    (2) 简化终止条件——由于每次循环过程都会计算终止条件，所以必须保证它尽可能快。也就是说避免属性查找或其他 O(n)的操作。
    (3) 简化循环体——循环体是执行最多的，所以要确保其被最大限度地优化。确保没有某些可以被很容易移出循环的密集计算。
    (4) 使用后测试循环——最常用 for 循环和 while 循环都是前测试循环。而如 do-while 这种后测试循环，可以避免最初终止条件的计算，因此运行更快。 

* 展开循环：当循环的次数是确定的，消除循环并使用多次函数调用往往更快。针对大数据集使用展开循环可以节省很多时间，但对于小数据集，额外的开销则可能得不偿失。它是要花更多的代码来完成同样的任务，如果处理的不是大数据集，一般来说并不值得。 
* 避免双重解释：当使用 eval()函数或者是Function 构造函数以及使用setTimeout()传一个字符串参数时都会发生双重解释惩罚。
```
eval("alert('Hello world!')");
var sayHi = new Function("alert('Hello world!')");
setTimeout("alert('Hello world!')", 500);
在以上这些例子中，都要解析包含了 JavaScript 代码的字符串。这个操作是不能在初始的解析过程中完成的，因为代码是包含在字符串中的，也就是说在 JavaScript 代码运行的同时必须新启动一个解析器来解析新的代码。实例化一个新的解析器有不容忽视的开销，所以这种代码要比直接解析慢得多。解决方案以下是一些例子：
//已修正
alert('Hello world!');
//创建新函数——已修正
var sayHi = function(){
 alert('Hello world!');
};
//设置一个超时——已修正
setTimeout(function(){
 alert('Hello world!');
}, 500); 
```

* 原生方法较快：例如，在 Math 对象中找到的复杂的数学运算；这些方法要比任何用 JavaScript 写的同样方法如正弦、余弦快的多。 
* Switch 语句较快 —— 如果有一系列复杂的 if-else 语句，可以转换成单个 switch 语句则可以得到更快的代码。还可以通过将 case 语句按照最可能的到最不可能的顺序进行组织，来进一步优化 switch 语句。
* 位运算符较快 —— 当进行数学运算的时候，位运算操作要比任何布尔运算或者算数运算快。选择性地用位运算替换算数运算可以极大提升复杂计算的性能。诸如取模，逻辑与和逻辑或都可以考虑用位运算来替换。
* 最小化语句数：JavaScript 代码中的语句数量也影响所执行的操作的速度。完成多个操作的单个语句要比完成单个操作的多个语句快。所以，就要找出可以组合在一起的语句，以减少脚本整体的执行时间。
    * 多个变量声明用一个var
    * 使用数组和对象字面量代替构造函数：使用构造函数总是要用到更多的语句来插入元素或者定义属性，而字面量可以将这些操作在一个语句中完成。
* 优化DOM交互：
    * 提交表单时可能出现的最大问题，就是重复提交表单。在第一次提交表单后，如果长时间没有反应，用户可能会变得不耐烦。这时候，他们也许会反复单击提交按钮。结果往往很麻烦（因为服务器要处理重复的请求），或者会造成错误（如果用户是下订单，那么可能会多订好几份）。解决这一问题的办法有两个：在第一次提交表单后就禁用提交按钮，或者利用 onsubmit 事件处理程序取消后续的表单提交操作。
    * 使用文档片段document.createDocumentFragment()来构建 DOM 结构，只有片段中的子节点被添加到目标，片段本身不会被添加的。
    * 使用 innerHTML：有两种在页面上创建 DOM 节点的方法：使用诸如 createElement()和 appendChild()之类的DOM 方法，以及使用 innerHTML。对于小的 DOM 更改而言，两种方法效率都差不多。然而，对于大的 DOM 更改，使用 innerHTML 要比使用标准 DOM 方法创建同样的 DOM 结构快得多。当把 innerHTML 设置为某个值时，后台会创建一个 HTML 解析器，然后使用内部的 DOM 调用来创建 DOM 结构，而非基于 JavaScript 的 DOM 调用。由于内部方法是编译好的而非解释执行的，所以执行快得多。
    * 使用事件代理：页面上的事件处理程序的数量和页面响应用户交互的速度之间有个负相关。为了减轻这种惩罚，最好使用事件代理。如果可能，在文档级别附加事件处理程序，这样可以处理整个页面的事件。
    * 最小化访问 HTMLCollection 的次数：任何时候要访问 HTMLCollection，不管它是一个属性还是一个方法，都是在文档上进行一个查询，这个查询开销很昂贵。发生以下情况时会返回 HTMLCollection 对象：
    (1) 进行了对 getElementsByTagName() 的调用；
    (2) 获取了元素的 childNodes 属性；
    (3) 获取了元素的 attributes 属性；
    (4) 访问了特殊的集合，如 document.forms、document.images 等。 

*  构建代码优化：利用webpack
